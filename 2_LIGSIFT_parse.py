#!/usr/bin/env python3

##########################################################################
#
#   Peter M.U. Ung @ MSSM
#
#   v1.0    --  15.05.26
#   v1.1    --  16.10.26    - bugfix
#
#   Purpose:    Call up LIGSIFT to perform 3D ligand-shape/chem comparison
#               similar to ROCS. Convert LIGSIFT output format to readable 
#               format after LIGSIFT generation.
#
#               Require the software LIGSIFT preinstalled
#               Use MPI processing to speed up LIGSIFT generation.
#
#
##########################################################################

import sys,os
msg = '''
    Usage: {0}
             -q     3D Query/Reference molecule     (sdf, mol2)
             -db    List of 3D Molecule databases name, no extension
                    (txt of SDF, SDF only)
             -cpu   Number of CPU to run            [default: 1]
             -o     Output prefix
             -rank  Output top ranking conformer    [default: 'ShapeSimPval']
            'ShapeTanimoto', 'ChemTanimoto', 'ShapeSim', 'ChemSim',
            'ShapeSimPval', 'ChemSimPval', 'TverskyShape', 'TverskyChem', 
            'TverskyChem'\n
    e.g.:   x.py -q=ref.mol2 -db=db.list -cpu=4 -o=result -rank=ShapeSimPval\n'''.format(sys.argv[0], Coef)
if len(sys.argv) > 6 or len(sys.argv) < 5: sys.exit(msg)

##########################################################################
# Convert LIGSIFT output format to readable format
Coef = {'ShapeTanimoto': 2, 'ChemTanimoto': 3,
        'ShapeSim': 4, 'ChemSim': 5,
        'ShapeSimPval': 6, 'ChemSimPval': 7,
        'TverskyShape': 8, 'TverskyChem': 9,
        'TverskyChem': 10}

Argv = {'-q':None, '-db':None, '-o':None, '-cpu':1, '-rank': 'ShapeSimPval'}

for item in sys.argv[1:]:
  Itms = item.split('=')
  Argv[Itms[0]] = Itms[1]

if '-rank' in Argv:
  if Argv['-rank'] not in Coef:
    print('  # Info: -rank keyword is wrong.')
    print('          Use default: ShapeSmiPval')
    Argv['-rank'] = 'ShapeSmiPval'
else:
  print('  # Info: -rank keyword is not defined.')
  print('          Use default: ShapeSmiPval')
  Argv['-rank'] = 'ShapeSimPval'
  
##########################################################################
import re,subprocess
import numpy as np

from tqdm import tqdm
from pathos import multiprocessing

##########################################################################

def main():
  mpi = multiprocessing.Pool(processes = int(Argv['-cpu']))
  lgf = RunLIGSIFT(ref_mol=Argv['-q'], output=Argv['-o'])

  # Open a list of database for shape-screening
  with file_handle(Argv['-db']) as fi:
    DBases = [line.rstrip() for line in fi]

  for dbase in DBases:
    Mol  = rdkit_open([dbase])
    Name = [m.GetProp('_Name') for m in Mol]
    Numb = range(1, len(Mol)+1)
    Data = [x for x in tqdm(mpi.imap_unordered(
                              lgf, list(zip(Mol, Name, Numb)),
                              total=len(list(zip(Mol, Name, Numb)))) ) ]
#    Data = mpi.map(lgf, list(zip(Mol, Name, Numb)))
    mpi.close()
    mpi.join()

  # Write out the information generated by LIGSIFT captured in stdout
  with open('_TEMP.xxx', 'w') as fx:
    for line, mol_dbase in Data:
      fx.write('{0} {1}\n'.format(line, mol_dbase))

  # Use the LIGSIFT stdout to generate the best-hit list and mol2 file
  for dbase_name in DBases:
    parse_data('_TEMP.xxx', Argv['-o'], dbase_name, Coef[Argv['-rank']])
  os.system('rm *_TEMP*')


##########################################################################
# Run LIGSIFT to compare ligand volume
class RunLIGSIFT(object):

  def __init__(self, ref_mol='', output=''):
    self.ref_mol = ref_mol
    self.output  = output

  def __call__(self, Itms):
    return self.run_ligsift(Itms)

  def run_ligsift(self, Itms):
    mol, name, idx = Itms
    print(' --> '+name+'\t'+str(idx))
    mol_dbase = '_TEMP.{0}.{1}'.format(name, idx)
    mol.SetProp('_Name', name)
    fo = Chem.SDWriter(mol_dbase+'.sdf')
    fo.write(mol)
    line = subprocess.check_output(
           'LIGSIFT -q {0} -db {1} -o {2} -s {3} -v -opt 2'.format(
               self.ref_mol, mol_dbase+'.sdf', 
               self.output+'.'+mol_dbase, 
               self.output+'.'+mol_dbase+'.mol2' ), shell=True )
    X = line.split('\n')
    for x in X:
      if re.search(r'Vol:', x):
        return x, ' {0}:{1}'.format(name, idx)
    os.system('rm '+mol_dbase+'.sdf')


##########################################################################
def parse_data(name, output, dbase_name, rank):

  ## Parse the LIGSIFT data line into tuples of lists, with the name and index
  ## of the ligand conformer appended to the end of the line
  Mol = []
  with open(name, 'r') as fi:
    for l in fi:
      line = re.sub(':',' ',l)
      i = line.split()
      m = [# db_mol, db_vol         ref_mol,ref_vol
            [i[0],i[2]],            [i[3],i[5]],
           #ShapeTc,value           ChemTc, value   
            [i[6],float(i[7])],     [i[8],float(i[9])],
           #ShapeSm,value           ChemSm, value 
            [i[10],float(i[11])],   [i[12],float(i[13])],
           #ShapePv,value                   ChemPv, value
            [i[14],-np.log10(float(i[15]))], [i[16],-np.log10(float(i[17]))],
           #ShapeTv, value          ChemTv, value
            [i[18],float(i[19])],   [i[20],float(i[21])],
           #ChargeTc,value
            [i[22],float(i[23])],
           #Mol_name,Mol_number
            [i[24],i[25]] 
          ]
      Mol.append(m)

  ## Group the ligand conformers by their ligand name
  Dict = {}
  for m in Mol:
    if m[0][0] in Dict:
      Dict[m[0][0]].append(m)
    else:
      Dict[m[0][0]] = [m]

  ## Select only 1 conformer of each ligand with the best defined coefficient,
  ## rank the ligands by the selected coefficient, and generate the 3D sdf file
  Best = []
  for key in Dict:
    Dict[key].sort(key=lambda x: x[rank][1], reverse=True)
    Best.append(Dict[key][0])
  Best.sort(key=lambda x: x[rank][1], reverse=True)
  cat_best_conformers(Best, output, dbase_name)

  with open(output+'.'+dbase_name+'.txt', 'wh') as fo:
    x = Mol[0]
    fo.write('Mol\tMol_Vol\t{0}_Vol\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}\t{7}\t{8}\t{9}\n'.format(
      x[1][0],x[2][0],x[3][0],x[4][0],x[5][0],x[6][0],x[7][0],x[8][0],x[9][0],x[10][0]))

    for m in Best:
      fo.write('{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}\t{7}\t{8}\t{9}\t{10}\t{11}\n'.format(
    m[0][0],m[1][1],m[0][1],m[2][1],m[3][1],m[4][1],m[5][1],m[6][1],m[7][1],
    m[8][1],m[9][1],m[10][1]
    ))
  

##########################################################################
## Use linux to concatinate all separate mol2 files into one, then use
## OpenBabel to convert them into sdf file for RDKit and other uses 
def cat_best_conformers(Data, output, dbase_name):
  out = 'cat '
  for Info in Data:
    name, idx = Info[11]
    mol_name  = output+'._TEMP.{0}.{1}.mol2'.format(name, idx)
    out = out+' '+mol_name
  out = out+' > '+output+'.'+dbase_name+'.cat.mol2'
  print(out)
  os.system(out)
  os.system('obabel -imol2 {0} -osdf > {1}'.format(
             output+'.'+dbase_name+'.cat.mol2',
             output+'.'+dbase_name+'.cat.sdf'))

  
##########################################################################
## Handle gzip and bzip2 file if the extension is right. otherwise, just open
## outuput: file handle
def file_handle(file_name):
  if re.search(r'.gz$', file_name):
    handle = gzip.open(file_name, 'rb')
  elif re.search(r'.bz2$', file_name):
    handle = bz2.BZ2File(file_name, 'rb')
  else:
    handle = (file_name)
  return handle

#######################################################################
## new version of rdkit distinguish the input source of the file, treating
## regular utf-8 file as str input and bytes file (zipped) as object input.
## Forward_supplier only takes bytes files and Regular_supplier takes regulars.
## To get around this, use file('x.sdf') to make utf-8 file as an object.

def rdkit_open(File_Tuple):

  List = []

  for f in (File_Tuple):
    handle = file_handle(f)

    if re.search(r'.sdf', f):
      Mol = [x for x in Chem.ForwardSDMolSupplier(handle, removeHs=True)
             if x is not None]

    if re.search(r'.smi', f):
      with open(f, 'r') as fi:
        first_line = fi.readline()

      if re.search(r'smiles', first_line, re.IGNORECASE):
        Mol = [x for x in Chem.SmilesMolSupplier(handle, titleLine=True,
                 delimiter=' |\t|,') if x is not None]
      else:
        Mol = [x for x in Chem.SmilesMolSupplier(handle, titleLine=False,
                 delimiter=' |\t|,') if x is not None]

    print( "\n# Found mol in {0}: {1}\n".format(f, len(Mol)))
    for mol in Mol: List.append(mol)

  return List

##########################################################################

if __name__ == '__main__':
  main()
